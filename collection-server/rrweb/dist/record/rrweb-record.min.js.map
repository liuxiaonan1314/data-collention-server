{"version":3,"file":"rrweb-record.min.js","sources":["../../node_modules/tslib/tslib.es6.js","../../node_modules/rrweb-snapshot/es/rrweb-snapshot.js","../../src/utils.ts","../../src/types.ts","../../src/record/mutation.ts","../../src/record/observer.ts","../../src/record/index.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","var NodeType;\n(function (NodeType) {\n    NodeType[NodeType[\"Document\"] = 0] = \"Document\";\n    NodeType[NodeType[\"DocumentType\"] = 1] = \"DocumentType\";\n    NodeType[NodeType[\"Element\"] = 2] = \"Element\";\n    NodeType[NodeType[\"Text\"] = 3] = \"Text\";\n    NodeType[NodeType[\"CDATA\"] = 4] = \"CDATA\";\n    NodeType[NodeType[\"Comment\"] = 5] = \"Comment\";\n})(NodeType || (NodeType = {}));\n\nvar _id = 1;\nvar symbolAndNumberRegex = RegExp('[^a-z1-6\\-]');\nfunction genId() {\n    return _id++;\n}\nfunction getValidTagName(tagName) {\n    var processedTagName = tagName.toLowerCase().trim();\n    if (symbolAndNumberRegex.test(processedTagName)) {\n        return 'div';\n    }\n    return processedTagName;\n}\nfunction getCssRulesString(s) {\n    try {\n        var rules = s.rules || s.cssRules;\n        return rules\n            ? Array.from(rules).reduce(function (prev, cur) { return prev + getCssRuleString(cur); }, '')\n            : null;\n    }\n    catch (error) {\n        return null;\n    }\n}\nfunction getCssRuleString(rule) {\n    return isCSSImportRule(rule)\n        ? getCssRulesString(rule.styleSheet) || ''\n        : rule.cssText;\n}\nfunction isCSSImportRule(rule) {\n    return 'styleSheet' in rule;\n}\nfunction extractOrigin(url) {\n    var origin;\n    if (url.indexOf('//') > -1) {\n        origin = url\n            .split('/')\n            .slice(0, 3)\n            .join('/');\n    }\n    else {\n        origin = url.split('/')[0];\n    }\n    origin = origin.split('?')[0];\n    return origin;\n}\nvar URL_IN_CSS_REF = /url\\((?:'([^']*)'|\"([^\"]*)\"|([^)]*))\\)/gm;\nvar RELATIVE_PATH = /^(?!www\\.|(?:http|ftp)s?:\\/\\/|[A-Za-z]:\\\\|\\/\\/).*/;\nvar DATA_URI = /^(data:)([\\w\\/\\+\\-]+);(charset=[\\w-]+|base64).*,(.*)/i;\nfunction absoluteToStylesheet(cssText, href) {\n    return (cssText || '').replace(URL_IN_CSS_REF, function (origin, path1, path2, path3) {\n        var filePath = path1 || path2 || path3;\n        if (!filePath) {\n            return origin;\n        }\n        if (!RELATIVE_PATH.test(filePath)) {\n            return \"url('\" + filePath + \"')\";\n        }\n        if (DATA_URI.test(filePath)) {\n            return \"url(\" + filePath + \")\";\n        }\n        if (filePath[0] === '/') {\n            return \"url('\" + (extractOrigin(href) + filePath) + \"')\";\n        }\n        var stack = href.split('/');\n        var parts = filePath.split('/');\n        stack.pop();\n        for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {\n            var part = parts_1[_i];\n            if (part === '.') {\n                continue;\n            }\n            else if (part === '..') {\n                stack.pop();\n            }\n            else {\n                stack.push(part);\n            }\n        }\n        return \"url('\" + stack.join('/') + \"')\";\n    });\n}\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\n    if (attributeValue.trim() === '') {\n        return attributeValue;\n    }\n    var srcsetValues = attributeValue.split(',');\n    var resultingSrcsetString = srcsetValues\n        .map(function (srcItem) {\n        var trimmedSrcItem = srcItem.trimLeft().trimRight();\n        var urlAndSize = trimmedSrcItem.split(' ');\n        if (urlAndSize.length === 2) {\n            var absUrl = absoluteToDoc(doc, urlAndSize[0]);\n            return absUrl + \" \" + urlAndSize[1];\n        }\n        else if (urlAndSize.length === 1) {\n            var absUrl = absoluteToDoc(doc, urlAndSize[0]);\n            return \"\" + absUrl;\n        }\n        return '';\n    })\n        .join(',');\n    return resultingSrcsetString;\n}\nfunction absoluteToDoc(doc, attributeValue) {\n    if (!attributeValue || attributeValue.trim() === '') {\n        return attributeValue;\n    }\n    var a = doc.createElement('a');\n    a.href = attributeValue;\n    return a.href;\n}\nfunction isSVGElement(el) {\n    return el.tagName === 'svg' || el instanceof SVGElement;\n}\nfunction transformAttribute(doc, name, value) {\n    if (name === 'src' || (name === 'href' && value)) {\n        return absoluteToDoc(doc, value);\n    }\n    else if (name === 'srcset' && value) {\n        return getAbsoluteSrcsetString(doc, value);\n    }\n    else if (name === 'style' && value) {\n        return absoluteToStylesheet(value, location.href);\n    }\n    else {\n        return value;\n    }\n}\nfunction serializeNode(n, doc, blockClass, inlineStylesheet, maskAllInputs) {\n    switch (n.nodeType) {\n        case n.DOCUMENT_NODE:\n            return {\n                type: NodeType.Document,\n                childNodes: []\n            };\n        case n.DOCUMENT_TYPE_NODE:\n            return {\n                type: NodeType.DocumentType,\n                name: n.name,\n                publicId: n.publicId,\n                systemId: n.systemId\n            };\n        case n.ELEMENT_NODE:\n            var needBlock_1 = false;\n            if (typeof blockClass === 'string') {\n                needBlock_1 = n.classList.contains(blockClass);\n            }\n            else {\n                n.classList.forEach(function (className) {\n                    if (blockClass.test(className)) {\n                        needBlock_1 = true;\n                    }\n                });\n            }\n            var tagName = getValidTagName(n.tagName);\n            var attributes_1 = {};\n            for (var _i = 0, _a = Array.from(n.attributes); _i < _a.length; _i++) {\n                var _b = _a[_i], name = _b.name, value = _b.value;\n                attributes_1[name] = transformAttribute(doc, name, value);\n            }\n            if (tagName === 'link' && inlineStylesheet) {\n                var stylesheet = Array.from(doc.styleSheets).find(function (s) {\n                    return s.href === n.href;\n                });\n                var cssText = getCssRulesString(stylesheet);\n                if (cssText) {\n                    delete attributes_1.rel;\n                    delete attributes_1.href;\n                    attributes_1._cssText = absoluteToStylesheet(cssText, stylesheet.href);\n                }\n            }\n            if (tagName === 'style' &&\n                n.sheet &&\n                !(n.innerText ||\n                    n.textContent ||\n                    '').trim().length) {\n                var cssText = getCssRulesString(n.sheet);\n                if (cssText) {\n                    attributes_1._cssText = absoluteToStylesheet(cssText, location.href);\n                }\n            }\n            if (tagName === 'input' ||\n                tagName === 'textarea' ||\n                tagName === 'select') {\n                var value = n.value;\n                if (attributes_1.type !== 'radio' &&\n                    attributes_1.type !== 'checkbox' &&\n                    value) {\n                    attributes_1.value = maskAllInputs ? '*'.repeat(value.length) : value;\n                }\n                else if (n.checked) {\n                    attributes_1.checked = n.checked;\n                }\n            }\n            if (tagName === 'option') {\n                var selectValue = n.parentElement;\n                if (attributes_1.value === selectValue.value) {\n                    attributes_1.selected = n.selected;\n                }\n            }\n            if (tagName === 'canvas') {\n                attributes_1.rr_dataURL = n.toDataURL();\n            }\n            if (tagName === 'audio' || tagName === 'video') {\n                attributes_1.rr_mediaState = n.paused\n                    ? 'paused'\n                    : 'played';\n            }\n            if (needBlock_1) {\n                var _c = n.getBoundingClientRect(), width = _c.width, height = _c.height;\n                attributes_1.rr_width = width + \"px\";\n                attributes_1.rr_height = height + \"px\";\n            }\n            return {\n                type: NodeType.Element,\n                tagName: tagName,\n                attributes: attributes_1,\n                childNodes: [],\n                isSVG: isSVGElement(n) || undefined,\n                needBlock: needBlock_1\n            };\n        case n.TEXT_NODE:\n            var parentTagName = n.parentNode && n.parentNode.tagName;\n            var textContent = n.textContent;\n            var isStyle = parentTagName === 'STYLE' ? true : undefined;\n            if (isStyle && textContent) {\n                textContent = absoluteToStylesheet(textContent, location.href);\n            }\n            if (parentTagName === 'SCRIPT') {\n                textContent = 'SCRIPT_PLACEHOLDER';\n            }\n            return {\n                type: NodeType.Text,\n                textContent: textContent || '',\n                isStyle: isStyle\n            };\n        case n.CDATA_SECTION_NODE:\n            return {\n                type: NodeType.CDATA,\n                textContent: ''\n            };\n        case n.COMMENT_NODE:\n            return {\n                type: NodeType.Comment,\n                textContent: n.textContent || ''\n            };\n        default:\n            return false;\n    }\n}\nfunction serializeNodeWithId(n, doc, map, blockClass, skipChild, inlineStylesheet, maskAllInputs) {\n    if (skipChild === void 0) { skipChild = false; }\n    if (inlineStylesheet === void 0) { inlineStylesheet = true; }\n    if (maskAllInputs === void 0) { maskAllInputs = false; }\n    var _serializedNode = serializeNode(n, doc, blockClass, inlineStylesheet, maskAllInputs);\n    if (!_serializedNode) {\n        console.warn(n, 'not serialized');\n        return null;\n    }\n    var id;\n    if ('__sn' in n) {\n        id = n.__sn.id;\n    }\n    else {\n        id = genId();\n    }\n    var serializedNode = Object.assign(_serializedNode, { id: id });\n    n.__sn = serializedNode;\n    map[id] = n;\n    var recordChild = !skipChild;\n    if (serializedNode.type === NodeType.Element) {\n        recordChild = recordChild && !serializedNode.needBlock;\n        delete serializedNode.needBlock;\n    }\n    if ((serializedNode.type === NodeType.Document ||\n        serializedNode.type === NodeType.Element) &&\n        recordChild) {\n        for (var _i = 0, _a = Array.from(n.childNodes); _i < _a.length; _i++) {\n            var childN = _a[_i];\n            var serializedChildNode = serializeNodeWithId(childN, doc, map, blockClass, skipChild, inlineStylesheet, maskAllInputs);\n            if (serializedChildNode) {\n                serializedNode.childNodes.push(serializedChildNode);\n            }\n        }\n    }\n    return serializedNode;\n}\nfunction snapshot(n, blockClass, inlineStylesheet, maskAllInputs) {\n    if (blockClass === void 0) { blockClass = 'rr-block'; }\n    if (inlineStylesheet === void 0) { inlineStylesheet = true; }\n    if (maskAllInputs === void 0) { maskAllInputs = false; }\n    var idNodeMap = {};\n    return [\n        serializeNodeWithId(n, n, idNodeMap, blockClass, false, inlineStylesheet, maskAllInputs),\n        idNodeMap,\n    ];\n}\n\nvar commentre = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\nfunction parse(css, options) {\n    if (options === void 0) { options = {}; }\n    var lineno = 1;\n    var column = 1;\n    function updatePosition(str) {\n        var lines = str.match(/\\n/g);\n        if (lines) {\n            lineno += lines.length;\n        }\n        var i = str.lastIndexOf('\\n');\n        column = i === -1 ? column + str.length : str.length - i;\n    }\n    function position() {\n        var start = { line: lineno, column: column };\n        return function (node) {\n            node.position = new Position(start);\n            whitespace();\n            return node;\n        };\n    }\n    var Position = (function () {\n        function Position(start) {\n            this.start = start;\n            this.end = { line: lineno, column: column };\n            this.source = options.source;\n        }\n        return Position;\n    }());\n    Position.prototype.content = css;\n    var errorsList = [];\n    function error(msg) {\n        var err = new Error(options.source + ':' + lineno + ':' + column + ': ' + msg);\n        err.reason = msg;\n        err.filename = options.source;\n        err.line = lineno;\n        err.column = column;\n        err.source = css;\n        if (options.silent) {\n            errorsList.push(err);\n        }\n        else {\n            throw err;\n        }\n    }\n    function stylesheet() {\n        var rulesList = rules();\n        return {\n            type: 'stylesheet',\n            stylesheet: {\n                source: options.source,\n                rules: rulesList,\n                parsingErrors: errorsList\n            }\n        };\n    }\n    function open() {\n        return match(/^{\\s*/);\n    }\n    function close() {\n        return match(/^}/);\n    }\n    function rules() {\n        var node;\n        var rules = [];\n        whitespace();\n        comments(rules);\n        while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {\n            if (node !== false) {\n                rules.push(node);\n                comments(rules);\n            }\n        }\n        return rules;\n    }\n    function match(re) {\n        var m = re.exec(css);\n        if (!m) {\n            return;\n        }\n        var str = m[0];\n        updatePosition(str);\n        css = css.slice(str.length);\n        return m;\n    }\n    function whitespace() {\n        match(/^\\s*/);\n    }\n    function comments(rules) {\n        if (rules === void 0) { rules = []; }\n        var c;\n        while ((c = comment())) {\n            if (c !== false) {\n                rules.push(c);\n            }\n            c = comment();\n        }\n        return rules;\n    }\n    function comment() {\n        var pos = position();\n        if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) {\n            return;\n        }\n        var i = 2;\n        while ('' !== css.charAt(i) &&\n            ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1))) {\n            ++i;\n        }\n        i += 2;\n        if ('' === css.charAt(i - 1)) {\n            return error('End of comment missing');\n        }\n        var str = css.slice(2, i - 2);\n        column += 2;\n        updatePosition(str);\n        css = css.slice(i);\n        column += 2;\n        return pos({\n            type: 'comment',\n            comment: str\n        });\n    }\n    function selector() {\n        var m = match(/^([^{]+)/);\n        if (!m) {\n            return;\n        }\n        return trim(m[0])\n            .replace(/\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*\\/+/g, '')\n            .replace(/\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'/g, function (m) {\n            return m.replace(/,/g, '\\u200C');\n        })\n            .split(/\\s*(?![^(]*\\)),\\s*/)\n            .map(function (s) {\n            return s.replace(/\\u200C/g, ',');\n        });\n    }\n    function declaration() {\n        var pos = position();\n        var propMatch = match(/^(\\*?[-#\\/\\*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/);\n        if (!propMatch) {\n            return;\n        }\n        var prop = trim(propMatch[0]);\n        if (!match(/^:\\s*/)) {\n            return error(\"property missing ':'\");\n        }\n        var val = match(/^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+)/);\n        var ret = pos({\n            type: 'declaration',\n            property: prop.replace(commentre, ''),\n            value: val ? trim(val[0]).replace(commentre, '') : ''\n        });\n        match(/^[;\\s]*/);\n        return ret;\n    }\n    function declarations() {\n        var decls = [];\n        if (!open()) {\n            return error(\"missing '{'\");\n        }\n        comments(decls);\n        var decl;\n        while ((decl = declaration())) {\n            if (decl !== false) {\n                decls.push(decl);\n                comments(decls);\n            }\n            decl = declaration();\n        }\n        if (!close()) {\n            return error(\"missing '}'\");\n        }\n        return decls;\n    }\n    function keyframe() {\n        var m;\n        var vals = [];\n        var pos = position();\n        while ((m = match(/^((\\d+\\.\\d+|\\.\\d+|\\d+)%?|[a-z]+)\\s*/))) {\n            vals.push(m[1]);\n            match(/^,\\s*/);\n        }\n        if (!vals.length) {\n            return;\n        }\n        return pos({\n            type: 'keyframe',\n            values: vals,\n            declarations: declarations()\n        });\n    }\n    function atkeyframes() {\n        var pos = position();\n        var m = match(/^@([-\\w]+)?keyframes\\s*/);\n        if (!m) {\n            return;\n        }\n        var vendor = m[1];\n        m = match(/^([-\\w]+)\\s*/);\n        if (!m) {\n            return error('@keyframes missing name');\n        }\n        var name = m[1];\n        if (!open()) {\n            return error(\"@keyframes missing '{'\");\n        }\n        var frame;\n        var frames = comments();\n        while ((frame = keyframe())) {\n            frames.push(frame);\n            frames = frames.concat(comments());\n        }\n        if (!close()) {\n            return error(\"@keyframes missing '}'\");\n        }\n        return pos({\n            type: 'keyframes',\n            name: name,\n            vendor: vendor,\n            keyframes: frames\n        });\n    }\n    function atsupports() {\n        var pos = position();\n        var m = match(/^@supports *([^{]+)/);\n        if (!m) {\n            return;\n        }\n        var supports = trim(m[1]);\n        if (!open()) {\n            return error(\"@supports missing '{'\");\n        }\n        var style = comments().concat(rules());\n        if (!close()) {\n            return error(\"@supports missing '}'\");\n        }\n        return pos({\n            type: 'supports',\n            supports: supports,\n            rules: style\n        });\n    }\n    function athost() {\n        var pos = position();\n        var m = match(/^@host\\s*/);\n        if (!m) {\n            return;\n        }\n        if (!open()) {\n            return error(\"@host missing '{'\");\n        }\n        var style = comments().concat(rules());\n        if (!close()) {\n            return error(\"@host missing '}'\");\n        }\n        return pos({\n            type: 'host',\n            rules: style\n        });\n    }\n    function atmedia() {\n        var pos = position();\n        var m = match(/^@media *([^{]+)/);\n        if (!m) {\n            return;\n        }\n        var media = trim(m[1]);\n        if (!open()) {\n            return error(\"@media missing '{'\");\n        }\n        var style = comments().concat(rules());\n        if (!close()) {\n            return error(\"@media missing '}'\");\n        }\n        return pos({\n            type: 'media',\n            media: media,\n            rules: style\n        });\n    }\n    function atcustommedia() {\n        var pos = position();\n        var m = match(/^@custom-media\\s+(--[^\\s]+)\\s*([^{;]+);/);\n        if (!m) {\n            return;\n        }\n        return pos({\n            type: 'custom-media',\n            name: trim(m[1]),\n            media: trim(m[2])\n        });\n    }\n    function atpage() {\n        var pos = position();\n        var m = match(/^@page */);\n        if (!m) {\n            return;\n        }\n        var sel = selector() || [];\n        if (!open()) {\n            return error(\"@page missing '{'\");\n        }\n        var decls = comments();\n        var decl;\n        while ((decl = declaration())) {\n            decls.push(decl);\n            decls = decls.concat(comments());\n        }\n        if (!close()) {\n            return error(\"@page missing '}'\");\n        }\n        return pos({\n            type: 'page',\n            selectors: sel,\n            declarations: decls\n        });\n    }\n    function atdocument() {\n        var pos = position();\n        var m = match(/^@([-\\w]+)?document *([^{]+)/);\n        if (!m) {\n            return;\n        }\n        var vendor = trim(m[1]);\n        var doc = trim(m[2]);\n        if (!open()) {\n            return error(\"@document missing '{'\");\n        }\n        var style = comments().concat(rules());\n        if (!close()) {\n            return error(\"@document missing '}'\");\n        }\n        return pos({\n            type: 'document',\n            document: doc,\n            vendor: vendor,\n            rules: style\n        });\n    }\n    function atfontface() {\n        var pos = position();\n        var m = match(/^@font-face\\s*/);\n        if (!m) {\n            return;\n        }\n        if (!open()) {\n            return error(\"@font-face missing '{'\");\n        }\n        var decls = comments();\n        var decl;\n        while ((decl = declaration())) {\n            decls.push(decl);\n            decls = decls.concat(comments());\n        }\n        if (!close()) {\n            return error(\"@font-face missing '}'\");\n        }\n        return pos({\n            type: 'font-face',\n            declarations: decls\n        });\n    }\n    var atimport = _compileAtrule('import');\n    var atcharset = _compileAtrule('charset');\n    var atnamespace = _compileAtrule('namespace');\n    function _compileAtrule(name) {\n        var re = new RegExp('^@' + name + '\\\\s*([^;]+);');\n        return function () {\n            var pos = position();\n            var m = match(re);\n            if (!m) {\n                return;\n            }\n            var ret = { type: name };\n            ret[name] = m[1].trim();\n            return pos(ret);\n        };\n    }\n    function atrule() {\n        if (css[0] !== '@') {\n            return;\n        }\n        return (atkeyframes() ||\n            atmedia() ||\n            atcustommedia() ||\n            atsupports() ||\n            atimport() ||\n            atcharset() ||\n            atnamespace() ||\n            atdocument() ||\n            atpage() ||\n            athost() ||\n            atfontface());\n    }\n    function rule() {\n        var pos = position();\n        var sel = selector();\n        if (!sel) {\n            return error('selector missing');\n        }\n        comments();\n        return pos({\n            type: 'rule',\n            selectors: sel,\n            declarations: declarations()\n        });\n    }\n    return addParent(stylesheet());\n}\nfunction trim(str) {\n    return str ? str.replace(/^\\s+|\\s+$/g, '') : '';\n}\nfunction addParent(obj, parent) {\n    var isNode = obj && typeof obj.type === 'string';\n    var childParent = isNode ? obj : parent;\n    for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {\n        var k = _a[_i];\n        var value = obj[k];\n        if (Array.isArray(value)) {\n            value.forEach(function (v) {\n                addParent(v, childParent);\n            });\n        }\n        else if (value && typeof value === 'object') {\n            addParent(value, childParent);\n        }\n    }\n    if (isNode) {\n        Object.defineProperty(obj, 'parent', {\n            configurable: true,\n            writable: true,\n            enumerable: false,\n            value: parent || null\n        });\n    }\n    return obj;\n}\n\nvar tagMap = {\n    script: 'noscript',\n    altglyph: 'altGlyph',\n    altglyphdef: 'altGlyphDef',\n    altglyphitem: 'altGlyphItem',\n    animatecolor: 'animateColor',\n    animatemotion: 'animateMotion',\n    animatetransform: 'animateTransform',\n    clippath: 'clipPath',\n    feblend: 'feBlend',\n    fecolormatrix: 'feColorMatrix',\n    fecomponenttransfer: 'feComponentTransfer',\n    fecomposite: 'feComposite',\n    feconvolvematrix: 'feConvolveMatrix',\n    fediffuselighting: 'feDiffuseLighting',\n    fedisplacementmap: 'feDisplacementMap',\n    fedistantlight: 'feDistantLight',\n    fedropshadow: 'feDropShadow',\n    feflood: 'feFlood',\n    fefunca: 'feFuncA',\n    fefuncb: 'feFuncB',\n    fefuncg: 'feFuncG',\n    fefuncr: 'feFuncR',\n    fegaussianblur: 'feGaussianBlur',\n    feimage: 'feImage',\n    femerge: 'feMerge',\n    femergenode: 'feMergeNode',\n    femorphology: 'feMorphology',\n    feoffset: 'feOffset',\n    fepointlight: 'fePointLight',\n    fespecularlighting: 'feSpecularLighting',\n    fespotlight: 'feSpotLight',\n    fetile: 'feTile',\n    feturbulence: 'feTurbulence',\n    foreignobject: 'foreignObject',\n    glyphref: 'glyphRef',\n    lineargradient: 'linearGradient',\n    radialgradient: 'radialGradient'\n};\nfunction getTagName(n) {\n    var tagName = tagMap[n.tagName] ? tagMap[n.tagName] : n.tagName;\n    if (tagName === 'link' && n.attributes._cssText) {\n        tagName = 'style';\n    }\n    return tagName;\n}\nvar HOVER_SELECTOR = /([^\\\\]):hover/g;\nfunction addHoverClass(cssText) {\n    var ast = parse(cssText, { silent: true });\n    if (!ast.stylesheet) {\n        return cssText;\n    }\n    ast.stylesheet.rules.forEach(function (rule) {\n        if ('selectors' in rule) {\n            (rule.selectors || []).forEach(function (selector) {\n                if (HOVER_SELECTOR.test(selector)) {\n                    var newSelector = selector.replace(HOVER_SELECTOR, '$1.\\\\:hover');\n                    cssText = cssText.replace(selector, selector + \", \" + newSelector);\n                }\n            });\n        }\n    });\n    return cssText;\n}\nfunction buildNode(n, doc, HACK_CSS) {\n    switch (n.type) {\n        case NodeType.Document:\n            return doc.implementation.createDocument(null, '', null);\n        case NodeType.DocumentType:\n            return doc.implementation.createDocumentType(n.name, n.publicId, n.systemId);\n        case NodeType.Element:\n            var tagName = getTagName(n);\n            var node_1;\n            if (n.isSVG) {\n                node_1 = doc.createElementNS('http://www.w3.org/2000/svg', tagName);\n            }\n            else {\n                node_1 = doc.createElement(tagName);\n            }\n            var _loop_1 = function (name) {\n                if (!n.attributes.hasOwnProperty(name)) {\n                    return \"continue\";\n                }\n                var value = n.attributes[name];\n                value = typeof value === 'boolean' ? '' : value;\n                if (!name.startsWith('rr_')) {\n                    var isTextarea = tagName === 'textarea' && name === 'value';\n                    var isRemoteOrDynamicCss = tagName === 'style' && name === '_cssText';\n                    if (isRemoteOrDynamicCss && HACK_CSS) {\n                        value = addHoverClass(value);\n                    }\n                    if (isTextarea || isRemoteOrDynamicCss) {\n                        var child = doc.createTextNode(value);\n                        for (var _i = 0, _a = Array.from(node_1.childNodes); _i < _a.length; _i++) {\n                            var c = _a[_i];\n                            if (c.nodeType === node_1.TEXT_NODE) {\n                                node_1.removeChild(c);\n                            }\n                        }\n                        node_1.appendChild(child);\n                        return \"continue\";\n                    }\n                    if (tagName === 'iframe' && name === 'src') {\n                        return \"continue\";\n                    }\n                    try {\n                        if (n.isSVG && name === 'xlink:href') {\n                            node_1.setAttributeNS('http://www.w3.org/1999/xlink', name, value);\n                        }\n                        else if (name == 'onload' || name == 'onclick' || name.substring(0, 7) == 'onmouse') {\n                            node_1.setAttribute('_' + name, value);\n                        }\n                        else {\n                            node_1.setAttribute(name, value);\n                        }\n                    }\n                    catch (error) {\n                    }\n                }\n                else {\n                    if (tagName === 'canvas' && name === 'rr_dataURL') {\n                        var image_1 = document.createElement('img');\n                        image_1.src = value;\n                        image_1.onload = function () {\n                            var ctx = node_1.getContext('2d');\n                            if (ctx) {\n                                ctx.drawImage(image_1, 0, 0, image_1.width, image_1.height);\n                            }\n                        };\n                    }\n                    if (name === 'rr_width') {\n                        node_1.style.width = value;\n                    }\n                    if (name === 'rr_height') {\n                        node_1.style.height = value;\n                    }\n                    if (name === 'rr_mediaState') {\n                        switch (value) {\n                            case 'played':\n                                node_1.play();\n                            case 'paused':\n                                node_1.pause();\n                                break;\n                            default:\n                        }\n                    }\n                }\n            };\n            for (var name in n.attributes) {\n                _loop_1(name);\n            }\n            return node_1;\n        case NodeType.Text:\n            return doc.createTextNode(n.isStyle && HACK_CSS ? addHoverClass(n.textContent) : n.textContent);\n        case NodeType.CDATA:\n            return doc.createCDATASection(n.textContent);\n        case NodeType.Comment:\n            return doc.createComment(n.textContent);\n        default:\n            return null;\n    }\n}\nfunction buildNodeWithSN(n, doc, map, skipChild, HACK_CSS) {\n    if (skipChild === void 0) { skipChild = false; }\n    if (HACK_CSS === void 0) { HACK_CSS = true; }\n    var node = buildNode(n, doc, HACK_CSS);\n    if (!node) {\n        return null;\n    }\n    if (n.type === NodeType.Document) {\n        doc.close();\n        doc.open();\n        node = doc;\n    }\n    node.__sn = n;\n    map[n.id] = node;\n    if ((n.type === NodeType.Document || n.type === NodeType.Element) &&\n        !skipChild) {\n        for (var _i = 0, _a = n.childNodes; _i < _a.length; _i++) {\n            var childN = _a[_i];\n            var childNode = buildNodeWithSN(childN, doc, map, false, HACK_CSS);\n            if (!childNode) {\n                console.warn('Failed to rebuild', childN);\n            }\n            else {\n                node.appendChild(childNode);\n            }\n        }\n    }\n    return node;\n}\nfunction rebuild(n, doc, HACK_CSS) {\n    if (HACK_CSS === void 0) { HACK_CSS = true; }\n    var idNodeMap = {};\n    return [buildNodeWithSN(n, doc, idNodeMap, false, HACK_CSS), idNodeMap];\n}\n\nexport { snapshot, serializeNodeWithId, rebuild, buildNodeWithSN, addHoverClass, transformAttribute, NodeType };\n","import {\n  Mirror,\n  throttleOptions,\n  listenerHandler,\n  hookResetter,\n  blockClass,\n} from './types';\nimport { INode } from 'rrweb-snapshot';\n\nexport function on(\n  type: string,\n  fn: EventListenerOrEventListenerObject,\n  target: Document | Window = document,\n): listenerHandler {\n  const options = { capture: true, passive: true };\n  target.addEventListener(type, fn, options);\n  return () => target.removeEventListener(type, fn, options);\n}\n\nexport const mirror: Mirror = {\n  map: {},\n  getId(n) {\n    // if n is not a serialized INode, use -1 as its id.\n    if (!n.__sn) {\n      return -1;\n    }\n    return n.__sn.id;\n  },\n  getNode(id) {\n    return mirror.map[id] || null;\n  },\n  // TODO: use a weakmap to get rid of manually memory management\n  removeNodeFromMap(n) {\n    const id = n.__sn && n.__sn.id;\n    delete mirror.map[id];\n    if (n.childNodes) {\n      n.childNodes.forEach((child) =>\n        mirror.removeNodeFromMap((child as Node) as INode),\n      );\n    }\n  },\n  has(id) {\n    return mirror.map.hasOwnProperty(id);\n  },\n};\n\n// copy from underscore and modified\nexport function throttle<T>(\n  func: (arg: T) => void,\n  wait: number,\n  options: throttleOptions = {},\n) {\n  let timeout: number | null = null;\n  let previous = 0;\n  // tslint:disable-next-line: only-arrow-functions\n  return function (arg: T) {\n    let now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    let remaining = wait - (now - previous);\n    let context = this;\n    let args = arguments;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        window.clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      func.apply(context, args);\n    } else if (!timeout && options.trailing !== false) {\n      timeout = window.setTimeout(() => {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        func.apply(context, args);\n      }, remaining);\n    }\n  };\n}\n\nexport function hookSetter<T>(\n  target: T,\n  key: string | number | symbol,\n  d: PropertyDescriptor,\n  isRevoked?: boolean,\n  win = window,\n): hookResetter {\n  const original = win.Object.getOwnPropertyDescriptor(target, key);\n  win.Object.defineProperty(\n    target,\n    key,\n    isRevoked\n      ? d\n      : {\n          set(value) {\n            // put hooked setter into event loop to avoid of set latency\n            setTimeout(() => {\n              d.set!.call(this, value);\n            }, 0);\n            if (original && original.set) {\n              original.set.call(this, value);\n            }\n          },\n        },\n  );\n  return () => hookSetter(target, key, original || {}, true);\n}\n\nexport function getWindowHeight(): number {\n  return (\n    window.innerHeight ||\n    (document.documentElement && document.documentElement.clientHeight) ||\n    (document.body && document.body.clientHeight)\n  );\n}\n\nexport function getWindowWidth(): number {\n  return (\n    window.innerWidth ||\n    (document.documentElement && document.documentElement.clientWidth) ||\n    (document.body && document.body.clientWidth)\n  );\n}\n\nexport function isBlocked(node: Node | null, blockClass: blockClass): boolean {\n  if (!node) {\n    return false;\n  }\n  if (node.nodeType === node.ELEMENT_NODE) {\n    let needBlock = false;\n    if (typeof blockClass === 'string') {\n      needBlock = (node as HTMLElement).classList.contains(blockClass);\n    } else {\n      (node as HTMLElement).classList.forEach((className) => {\n        if (blockClass.test(className)) {\n          needBlock = true;\n        }\n      });\n    }\n    return needBlock || isBlocked(node.parentNode, blockClass);\n  }\n  return isBlocked(node.parentNode, blockClass);\n}\n\nexport function isAncestorRemoved(target: INode): boolean {\n  const id = mirror.getId(target);\n  if (!mirror.has(id)) {\n    return true;\n  }\n  if (\n    target.parentNode &&\n    target.parentNode.nodeType === target.DOCUMENT_NODE\n  ) {\n    return false;\n  }\n  // if the root is not document, it means the node is not in the DOM tree anymore\n  if (!target.parentNode) {\n    return true;\n  }\n  return isAncestorRemoved((target.parentNode as unknown) as INode);\n}\n\nexport function isTouchEvent(\n  event: MouseEvent | TouchEvent,\n): event is TouchEvent {\n  return Boolean((event as TouchEvent).changedTouches);\n}\n\nexport function polyfill() {\n  if ('NodeList' in window && !NodeList.prototype.forEach) {\n    NodeList.prototype.forEach = (Array.prototype\n      .forEach as unknown) as NodeList['forEach'];\n  }\n}\n","import { serializedNodeWithId, idNodeMap, INode } from 'rrweb-snapshot';\nimport { PackFn, UnpackFn } from './packer/base';\n\nexport enum EventType {\n  DomContentLoaded,\n  Load,\n  FullSnapshot,\n  IncrementalSnapshot,\n  Meta,\n  Custom,\n}\n\nexport type domContentLoadedEvent = {\n  type: EventType.DomContentLoaded;\n  data: {};\n};\n\nexport type loadedEvent = {\n  type: EventType.Load;\n  data: {};\n};\n\nexport type fullSnapshotEvent = {\n  type: EventType.FullSnapshot;\n  data: {\n    node: serializedNodeWithId;\n    initialOffset: {\n      top: number;\n      left: number;\n    };\n  };\n};\n\nexport type incrementalSnapshotEvent = {\n  type: EventType.IncrementalSnapshot;\n  data: incrementalData;\n};\n\nexport type metaEvent = {\n  type: EventType.Meta;\n  data: {\n    href: string;\n    width: number;\n    height: number;\n  };\n};\n\nexport type customEvent<T = unknown> = {\n  type: EventType.Custom;\n  data: {\n    tag: string;\n    payload: T;\n  };\n};\n\nexport type styleSheetEvent = {};\n\nexport enum IncrementalSource {\n  Mutation,\n  MouseMove,\n  MouseInteraction,\n  Scroll,\n  ViewportResize,\n  Input,\n  TouchMove,\n  MediaInteraction,\n  StyleSheetRule,\n}\n\nexport type mutationData = {\n  source: IncrementalSource.Mutation;\n} & mutationCallbackParam;\n\nexport type mousemoveData = {\n  source: IncrementalSource.MouseMove | IncrementalSource.TouchMove;\n  positions: mousePosition[];\n};\n\nexport type mouseInteractionData = {\n  source: IncrementalSource.MouseInteraction;\n} & mouseInteractionParam;\n\nexport type scrollData = {\n  source: IncrementalSource.Scroll;\n} & scrollPosition;\n\nexport type viewportResizeData = {\n  source: IncrementalSource.ViewportResize;\n} & viewportResizeDimention;\n\nexport type inputData = {\n  source: IncrementalSource.Input;\n  id: number;\n} & inputValue;\n\nexport type mediaInteractionData = {\n  source: IncrementalSource.MediaInteraction;\n} & mediaInteractionParam;\n\nexport type styleSheetRuleData = {\n  source: IncrementalSource.StyleSheetRule;\n} & styleSheetRuleParam;\n\nexport type incrementalData =\n  | mutationData\n  | mousemoveData\n  | mouseInteractionData\n  | scrollData\n  | viewportResizeData\n  | inputData\n  | mediaInteractionData\n  | styleSheetRuleData;\n\nexport type event =\n  | domContentLoadedEvent\n  | loadedEvent\n  | fullSnapshotEvent\n  | incrementalSnapshotEvent\n  | metaEvent\n  | customEvent;\n\nexport type eventWithTime = event & {\n  timestamp: number;\n  delay?: number;\n};\n\nexport type blockClass = string | RegExp;\n\nexport type recordOptions<T> = {\n  emit?: (e: T, isCheckout?: boolean) => void;\n  checkoutEveryNth?: number;\n  checkoutEveryNms?: number;\n  blockClass?: blockClass;\n  ignoreClass?: string;\n  maskAllInputs?: boolean;\n  inlineStylesheet?: boolean;\n  hooks?: hooksParam;\n  mousemoveWait?: number;\n  packFn?: PackFn;\n};\n\nexport type observerParam = {\n  mutationCb: mutationCallBack;\n  mousemoveCb: mousemoveCallBack;\n  mouseInteractionCb: mouseInteractionCallBack;\n  scrollCb: scrollCallback;\n  viewportResizeCb: viewportResizeCallback;\n  inputCb: inputCallback;\n  mediaInteractionCb: mediaInteractionCallback;\n  blockClass: blockClass;\n  ignoreClass: string;\n  maskAllInputs: boolean;\n  inlineStylesheet: boolean;\n  styleSheetRuleCb: styleSheetRuleCallback;\n  mousemoveWait: number;\n};\n\nexport type hooksParam = {\n  mutation?: mutationCallBack;\n  mousemove?: mousemoveCallBack;\n  mouseInteraction?: mouseInteractionCallBack;\n  scroll?: scrollCallback;\n  viewportResize?: viewportResizeCallback;\n  input?: inputCallback;\n  mediaInteaction?: mediaInteractionCallback;\n  styleSheetRule?: styleSheetRuleCallback;\n};\n\n// https://dom.spec.whatwg.org/#interface-mutationrecord\nexport type mutationRecord = {\n  type: string,\n  target: Node,\n  oldValue: string | null,\n  addedNodes: NodeList,\n  removedNodes: NodeList,\n  attributeName: string | null,\n}\n\nexport type textCursor = {\n  node: Node;\n  value: string | null;\n};\nexport type textMutation = {\n  id: number;\n  value: string | null;\n};\n\nexport type attributeCursor = {\n  node: Node;\n  attributes: {\n    [key: string]: string | null;\n  };\n};\nexport type attributeMutation = {\n  id: number;\n  attributes: {\n    [key: string]: string | null;\n  };\n};\n\nexport type removedNodeMutation = {\n  parentId: number;\n  id: number;\n};\n\nexport type addedNodeMutation = {\n  parentId: number;\n  // Newly recorded mutations will not have previousId any more, just for compatibility\n  previousId?: number | null;\n  nextId: number | null;\n  node: serializedNodeWithId;\n};\n\ntype mutationCallbackParam = {\n  texts: textMutation[];\n  attributes: attributeMutation[];\n  removes: removedNodeMutation[];\n  adds: addedNodeMutation[];\n};\n\nexport type mutationCallBack = (m: mutationCallbackParam) => void;\n\nexport type mousemoveCallBack = (\n  p: mousePosition[],\n  source: IncrementalSource.MouseMove | IncrementalSource.TouchMove,\n) => void;\n\nexport type mousePosition = {\n  x: number;\n  y: number;\n  id: number;\n  timeOffset: number;\n};\n\nexport enum MouseInteractions {\n  MouseUp,\n  MouseDown,\n  Click,\n  ContextMenu,\n  DblClick,\n  Focus,\n  Blur,\n  TouchStart,\n  TouchMove_Departed, // we will start a separate observer for touch move event\n  TouchEnd,\n}\n\ntype mouseInteractionParam = {\n  type: MouseInteractions;\n  id: number;\n  x: number;\n  y: number;\n};\n\nexport type mouseInteractionCallBack = (d: mouseInteractionParam) => void;\n\nexport type scrollPosition = {\n  id: number;\n  x: number;\n  y: number;\n};\n\nexport type scrollCallback = (p: scrollPosition) => void;\n\nexport type styleSheetAddRule = {\n  rule: string;\n  index?: number;\n};\n\nexport type styleSheetDeleteRule = {\n  index: number;\n};\n\nexport type styleSheetRuleParam = {\n  id: number;\n  removes?: styleSheetDeleteRule[];\n  adds?: styleSheetAddRule[];\n};\n\nexport type styleSheetRuleCallback = (s: styleSheetRuleParam) => void;\n\nexport type viewportResizeDimention = {\n  width: number;\n  height: number;\n};\n\nexport type viewportResizeCallback = (d: viewportResizeDimention) => void;\n\nexport type inputValue = {\n  text: string;\n  isChecked: boolean;\n};\n\nexport type inputCallback = (v: inputValue & { id: number }) => void;\n\nexport const enum MediaInteractions {\n  Play,\n  Pause,\n}\n\nexport type mediaInteractionParam = {\n  type: MediaInteractions;\n  id: number;\n};\n\nexport type mediaInteractionCallback = (p: mediaInteractionParam) => void;\n\nexport type Mirror = {\n  map: idNodeMap;\n  getId: (n: INode) => number;\n  getNode: (id: number) => INode | null;\n  removeNodeFromMap: (n: INode) => void;\n  has: (id: number) => boolean;\n};\n\nexport type throttleOptions = {\n  leading?: boolean;\n  trailing?: boolean;\n};\n\nexport type listenerHandler = () => void;\nexport type hookResetter = () => void;\n\nexport type playerConfig = {\n  speed: number;\n  root: Element;\n  loadTimeout: number;\n  skipInactive: boolean;\n  showWarning: boolean;\n  showDebug: boolean;\n  blockClass: string;\n  liveMode: boolean;\n  insertStyleRules: string[];\n  triggerFocus: boolean;\n  unpackFn?: UnpackFn;\n};\n\nexport type playerMetaData = {\n  totalTime: number;\n};\n\nexport type missingNode = {\n  node: Node;\n  mutation: addedNodeMutation;\n};\nexport type missingNodeMap = {\n  [id: number]: missingNode;\n};\n\nexport type actionWithDelay = {\n  doAction: () => void;\n  delay: number;\n};\n\nexport type Handler = (event?: unknown) => void;\n\nexport type Emitter = {\n  on(type: string, handler: Handler): void;\n  emit(type: string, event?: unknown): void;\n};\n\nexport type Arguments<T> = T extends (...payload: infer U) => unknown\n  ? U\n  : unknown;\n\nexport enum ReplayerEvents {\n  Start = 'start',\n  Pause = 'pause',\n  Resume = 'resume',\n  Resize = 'resize',\n  Finish = 'finish',\n  FullsnapshotRebuilded = 'fullsnapshot-rebuilded',\n  LoadStylesheetStart = 'load-stylesheet-start',\n  LoadStylesheetEnd = 'load-stylesheet-end',\n  SkipStart = 'skip-start',\n  SkipEnd = 'skip-end',\n  MouseInteraction = 'mouse-interaction',\n  EventCast = 'event-cast',\n  CustomEvent = 'custom-event',\n}\n","import { INode, serializeNodeWithId, transformAttribute } from 'rrweb-snapshot';\nimport {\n  mutationRecord,\n  blockClass,\n  mutationCallBack,\n  textCursor,\n  attributeCursor,\n  removedNodeMutation,\n  addedNodeMutation,\n} from '../types';\nimport { mirror, isBlocked, isAncestorRemoved } from '../utils';\n\nconst moveKey = (id: number, parentId: number) => `${id}@${parentId}`;\nfunction isINode(n: Node | INode): n is INode {\n  return '__sn' in n;\n}\n\n/**\n * controls behaviour of a MutationObserver\n */\nexport default class MutationBuffer {\n  private texts: textCursor[] = [];\n  private attributes: attributeCursor[] = [];\n  private removes: removedNodeMutation[] = [];\n  private adds: addedNodeMutation[] = [];\n\n  private movedMap: Record<string, true> = {};\n\n  /**\n   * the browser MutationObserver emits multiple mutations after\n   * a delay for performance reasons, making tracing added nodes hard\n   * in our `processMutations` callback function.\n   * For example, if we append an element el_1 into body, and then append\n   * another element el_2 into el_1, these two mutations may be passed to the\n   * callback function together when the two operations were done.\n   * Generally we need to trace child nodes of newly added nodes, but in this\n   * case if we count el_2 as el_1's child node in the first mutation record,\n   * then we will count el_2 again in the second mutation record which was\n   * duplicated.\n   * To avoid of duplicate counting added nodes, we use a Set to store\n   * added nodes and its child nodes during iterate mutation records. Then\n   * collect added nodes from the Set which have no duplicate copy. But\n   * this also causes newly added nodes will not be serialized with id ASAP,\n   * which means all the id related calculation should be lazy too.\n   */\n  private addedSet = new Set<Node>();\n  private movedSet = new Set<Node>();\n  private droppedSet = new Set<Node>();\n\n  private emissionCallback: mutationCallBack;\n  private blockClass: blockClass;\n  private inlineStylesheet: boolean;\n  private maskAllInputs: boolean;\n\n  constructor(\n    cb: mutationCallBack,\n    blockClass: blockClass,\n    inlineStylesheet: boolean,\n    maskAllInputs: boolean,\n  ) {\n    this.blockClass = blockClass;\n    this.inlineStylesheet = inlineStylesheet;\n    this.maskAllInputs = maskAllInputs;\n    this.emissionCallback = cb;\n  }\n\n  public processMutations = (mutations: mutationRecord[]) => {\n    mutations.forEach(this.processMutation);\n\n    /**\n     * Sometimes child node may be pushed before its newly added\n     * parent, so we init a queue to store these nodes.\n     */\n    const addQueue: Node[] = [];\n    const pushAdd = (n: Node) => {\n      const parentId = mirror.getId((n.parentNode as Node) as INode);\n      const nextId =\n        n.nextSibling && mirror.getId((n.nextSibling as unknown) as INode);\n      if (parentId === -1 || nextId === -1) {\n        return addQueue.push(n);\n      }\n      this.adds.push({\n        parentId,\n        nextId,\n        node: serializeNodeWithId(\n          n,\n          document,\n          mirror.map,\n          this.blockClass,\n          true,\n          this.inlineStylesheet,\n          this.maskAllInputs,\n        )!,\n      });\n    };\n\n    for (const n of this.movedSet) {\n      pushAdd(n);\n    }\n\n    for (const n of this.addedSet) {\n      if (\n        !isAncestorInSet(this.droppedSet, n) &&\n        !isParentRemoved(this.removes, n)\n      ) {\n        pushAdd(n);\n      } else if (isAncestorInSet(this.movedSet, n)) {\n        pushAdd(n);\n      } else {\n        this.droppedSet.add(n);\n      }\n    }\n\n    while (addQueue.length) {\n      if (\n        addQueue.every(\n          (n) => mirror.getId((n.parentNode as Node) as INode) === -1,\n        )\n      ) {\n        /**\n         * If all nodes in queue could not find a serialized parent,\n         * it may be a bug or corner case. We need to escape the\n         * dead while loop at once.\n         */\n        break;\n      }\n      pushAdd(addQueue.shift()!);\n    }\n\n    this.emit();\n  };\n\n  private processMutation = (m: mutationRecord) => {\n    switch (m.type) {\n      case 'characterData': {\n        const value = m.target.textContent;\n        if (!isBlocked(m.target, this.blockClass) && value !== m.oldValue) {\n          this.texts.push({\n            value,\n            node: m.target,\n          });\n        }\n        break;\n      }\n      case 'attributes': {\n        const value = (m.target as HTMLElement).getAttribute(m.attributeName!);\n        if (isBlocked(m.target, this.blockClass) || value === m.oldValue) {\n          return;\n        }\n        let item: attributeCursor | undefined = this.attributes.find(\n          (a) => a.node === m.target,\n        );\n        if (!item) {\n          item = {\n            node: m.target,\n            attributes: {},\n          };\n          this.attributes.push(item);\n        }\n        // overwrite attribute if the mutations was triggered in same time\n        item.attributes[m.attributeName!] = transformAttribute(\n          document,\n          m.attributeName!,\n          value!,\n        );\n        break;\n      }\n      case 'childList': {\n        m.addedNodes.forEach((n) => this.genAdds(n, m.target));\n        m.removedNodes.forEach((n) => {\n          const nodeId = mirror.getId(n as INode);\n          const parentId = mirror.getId(m.target as INode);\n          if (isBlocked(n, this.blockClass)) {\n            return;\n          }\n          // removed node has not been serialized yet, just remove it from the Set\n          if (this.addedSet.has(n)) {\n            deepDelete(this.addedSet, n);\n            this.droppedSet.add(n);\n          } else if (this.addedSet.has(m.target) && nodeId === -1) {\n            /**\n             * If target was newly added and removed child node was\n             * not serialized, it means the child node has been removed\n             * before callback fired, so we can ignore it because\n             * newly added node will be serialized without child nodes.\n             * TODO: verify this\n             */\n          } else if (isAncestorRemoved(m.target as INode)) {\n            /**\n             * If parent id was not in the mirror map any more, it\n             * means the parent node has already been removed. So\n             * the node is also removed which we do not need to track\n             * and replay.\n             */\n          } else if (\n            this.movedSet.has(n) &&\n            this.movedMap[moveKey(nodeId, parentId)]\n          ) {\n            deepDelete(this.movedSet, n);\n          } else {\n            this.removes.push({\n              parentId,\n              id: nodeId,\n            });\n          }\n          mirror.removeNodeFromMap(n as INode);\n        });\n        break;\n      }\n      default:\n        break;\n    }\n  };\n\n  private genAdds = (n: Node | INode, target?: Node | INode) => {\n    if (isBlocked(n, this.blockClass)) {\n      return;\n    }\n    if (isINode(n)) {\n      this.movedSet.add(n);\n      let targetId: number | null = null;\n      if (target && isINode(target)) {\n        targetId = target.__sn.id;\n      }\n      if (targetId) {\n        this.movedMap[moveKey(n.__sn.id, targetId)] = true;\n      }\n    } else {\n      this.addedSet.add(n);\n      this.droppedSet.delete(n);\n    }\n    n.childNodes.forEach((childN) => this.genAdds(childN));\n  };\n\n  public emit = () => {\n    const payload = {\n      texts: this.texts\n        .map((text) => ({\n          id: mirror.getId(text.node as INode),\n          value: text.value,\n        }))\n        // text mutation's id was not in the mirror map means the target node has been removed\n        .filter((text) => mirror.has(text.id)),\n      attributes: this.attributes\n        .map((attribute) => ({\n          id: mirror.getId(attribute.node as INode),\n          attributes: attribute.attributes,\n        }))\n        // attribute mutation's id was not in the mirror map means the target node has been removed\n        .filter((attribute) => mirror.has(attribute.id)),\n      removes: this.removes,\n      adds: this.adds,\n    };\n    // payload may be empty if the mutations happened in some blocked elements\n    if (\n      !payload.texts.length &&\n      !payload.attributes.length &&\n      !payload.removes.length &&\n      !payload.adds.length\n    ) {\n      return;\n    }\n    this.emissionCallback(payload);\n\n    // reset\n    this.texts = [];\n    this.attributes = [];\n    this.removes = [];\n    this.adds = [];\n    this.addedSet = new Set<Node>();\n    this.movedSet = new Set<Node>();\n    this.droppedSet = new Set<Node>();\n    this.movedMap = {};\n  };\n}\n\n/**\n * Some utils to handle the mutation observer DOM records.\n * It should be more clear to extend the native data structure\n * like Set and Map, but currently Typescript does not support\n * that.\n */\nfunction deepDelete(addsSet: Set<Node>, n: Node) {\n  addsSet.delete(n);\n  n.childNodes.forEach((childN) => deepDelete(addsSet, childN));\n}\n\nfunction isParentRemoved(removes: removedNodeMutation[], n: Node): boolean {\n  const { parentNode } = n;\n  if (!parentNode) {\n    return false;\n  }\n  const parentId = mirror.getId((parentNode as Node) as INode);\n  if (removes.some((r) => r.id === parentId)) {\n    return true;\n  }\n  return isParentRemoved(removes, parentNode);\n}\n\nfunction isAncestorInSet(set: Set<Node>, n: Node): boolean {\n  const { parentNode } = n;\n  if (!parentNode) {\n    return false;\n  }\n  if (set.has(parentNode)) {\n    return true;\n  }\n  return isAncestorInSet(set, parentNode);\n}\n","import { INode } from 'rrweb-snapshot';\nimport {\n  mirror,\n  throttle,\n  on,\n  hookSetter,\n  getWindowHeight,\n  getWindowWidth,\n  isBlocked,\n  isTouchEvent,\n} from '../utils';\nimport {\n  mutationCallBack,\n  observerParam,\n  mousemoveCallBack,\n  mousePosition,\n  mouseInteractionCallBack,\n  MouseInteractions,\n  listenerHandler,\n  scrollCallback,\n  styleSheetRuleCallback,\n  viewportResizeCallback,\n  inputValue,\n  inputCallback,\n  hookResetter,\n  blockClass,\n  IncrementalSource,\n  hooksParam,\n  Arguments,\n  mediaInteractionCallback,\n  MediaInteractions,\n} from '../types';\nimport MutationBuffer from './mutation';\n\nfunction initMutationObserver(\n  cb: mutationCallBack,\n  blockClass: blockClass,\n  inlineStylesheet: boolean,\n  maskAllInputs: boolean,\n): MutationObserver {\n  // see mutation.ts for details\n  const mutationBuffer = new MutationBuffer(\n    cb,\n    blockClass,\n    inlineStylesheet,\n    maskAllInputs,\n  );\n  const observer = new MutationObserver(mutationBuffer.processMutations);\n  observer.observe(document, {\n    attributes: true,\n    attributeOldValue: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true,\n  });\n  return observer;\n}\n\nfunction initMoveObserver(\n  cb: mousemoveCallBack,\n  mousemoveWait: number,\n): listenerHandler {\n  let positions: mousePosition[] = [];\n  let timeBaseline: number | null;\n  const wrappedCb = throttle((isTouch: boolean) => {\n    const totalOffset = Date.now() - timeBaseline!;\n    cb(\n      positions.map((p) => {\n        p.timeOffset -= totalOffset;\n        return p;\n      }),\n      isTouch ? IncrementalSource.TouchMove : IncrementalSource.MouseMove,\n    );\n    positions = [];\n    timeBaseline = null;\n  }, 500);\n  const updatePosition = throttle<MouseEvent | TouchEvent>(\n    (evt) => {\n      const { target } = evt;\n      const { clientX, clientY } = isTouchEvent(evt)\n        ? evt.changedTouches[0]\n        : evt;\n      if (!timeBaseline) {\n        timeBaseline = Date.now();\n      }\n      positions.push({\n        x: clientX,\n        y: clientY,\n        id: mirror.getId(target as INode),\n        timeOffset: Date.now() - timeBaseline,\n      });\n      wrappedCb(isTouchEvent(evt));\n    },\n    mousemoveWait,\n    {\n      trailing: false,\n    },\n  );\n  const handlers = [\n    on('mousemove', updatePosition),\n    on('touchmove', updatePosition),\n  ];\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initMouseInteractionObserver(\n  cb: mouseInteractionCallBack,\n  blockClass: blockClass,\n): listenerHandler {\n  const handlers: listenerHandler[] = [];\n  const getHandler = (eventKey: keyof typeof MouseInteractions) => {\n    return (event: MouseEvent | TouchEvent) => {\n      if (isBlocked(event.target as Node, blockClass)) {\n        return;\n      }\n      const id = mirror.getId(event.target as INode);\n      const { clientX, clientY } = isTouchEvent(event)\n        ? event.changedTouches[0]\n        : event;\n      cb({\n        type: MouseInteractions[eventKey],\n        id,\n        x: clientX,\n        y: clientY,\n      });\n    };\n  };\n  Object.keys(MouseInteractions)\n    .filter((key) => Number.isNaN(Number(key)) && !key.endsWith('_Departed'))\n    .forEach((eventKey: keyof typeof MouseInteractions) => {\n      const eventName = eventKey.toLowerCase();\n      const handler = getHandler(eventKey);\n      handlers.push(on(eventName, handler));\n    });\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initScrollObserver(\n  cb: scrollCallback,\n  blockClass: blockClass,\n): listenerHandler {\n  const updatePosition = throttle<UIEvent>((evt) => {\n    if (!evt.target || isBlocked(evt.target as Node, blockClass)) {\n      return;\n    }\n    const id = mirror.getId(evt.target as INode);\n    if (evt.target === document) {\n      const scrollEl = (document.scrollingElement || document.documentElement)!;\n      cb({\n        id,\n        x: scrollEl.scrollLeft,\n        y: scrollEl.scrollTop,\n      });\n    } else {\n      cb({\n        id,\n        x: (evt.target as HTMLElement).scrollLeft,\n        y: (evt.target as HTMLElement).scrollTop,\n      });\n    }\n  }, 100);\n  return on('scroll', updatePosition);\n}\n\nfunction initViewportResizeObserver(\n  cb: viewportResizeCallback,\n): listenerHandler {\n  const updateDimension = throttle(() => {\n    const height = getWindowHeight();\n    const width = getWindowWidth();\n    cb({\n      width: Number(width),\n      height: Number(height),\n    });\n  }, 200);\n  return on('resize', updateDimension, window);\n}\n\nexport const INPUT_TAGS = ['INPUT', 'TEXTAREA', 'SELECT'];\nexport const MASK_TYPES = [\n  'color',\n  'date',\n  'datetime-local',\n  'email',\n  'month',\n  'number',\n  'range',\n  'search',\n  'tel',\n  'text',\n  'time',\n  'url',\n  'week',\n];\nconst lastInputValueMap: WeakMap<EventTarget, inputValue> = new WeakMap();\nfunction initInputObserver(\n  cb: inputCallback,\n  blockClass: blockClass,\n  ignoreClass: string,\n  maskAllInputs: boolean,\n): listenerHandler {\n  function eventHandler(event: Event) {\n    const { target } = event;\n    if (\n      !target ||\n      !(target as Element).tagName ||\n      INPUT_TAGS.indexOf((target as Element).tagName) < 0 ||\n      isBlocked(target as Node, blockClass)\n    ) {\n      return;\n    }\n    const type: string | undefined = (target as HTMLInputElement).type;\n    if (\n      type === 'password' ||\n      (target as HTMLElement).classList.contains(ignoreClass)\n    ) {\n      return;\n    }\n    let text = (target as HTMLInputElement).value;\n    let isChecked = false;\n    const hasTextInput =\n      MASK_TYPES.includes(type) || (target as Element).tagName === 'TEXTAREA';\n    if (type === 'radio' || type === 'checkbox') {\n      isChecked = (target as HTMLInputElement).checked;\n    } else if (hasTextInput && maskAllInputs) {\n      text = '*'.repeat(text.length);\n    }\n    cbWithDedup(target, { text, isChecked });\n    // if a radio was checked\n    // the other radios with the same name attribute will be unchecked.\n    const name: string | undefined = (target as HTMLInputElement).name;\n    if (type === 'radio' && name && isChecked) {\n      document\n        .querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`)\n        .forEach((el) => {\n          if (el !== target) {\n            cbWithDedup(el, {\n              text: (el as HTMLInputElement).value,\n              isChecked: !isChecked,\n            });\n          }\n        });\n    }\n  }\n  function cbWithDedup(target: EventTarget, v: inputValue) {\n    const lastInputValue = lastInputValueMap.get(target);\n    if (\n      !lastInputValue ||\n      lastInputValue.text !== v.text ||\n      lastInputValue.isChecked !== v.isChecked\n    ) {\n      lastInputValueMap.set(target, v);\n      const id = mirror.getId(target as INode);\n      cb({\n        ...v,\n        id,\n      });\n    }\n  }\n  const handlers: Array<listenerHandler | hookResetter> = [\n    'input',\n    'change',\n  ].map((eventName) => on(eventName, eventHandler));\n  const propertyDescriptor = Object.getOwnPropertyDescriptor(\n    HTMLInputElement.prototype,\n    'value',\n  );\n  const hookProperties: Array<[HTMLElement, string]> = [\n    [HTMLInputElement.prototype, 'value'],\n    [HTMLInputElement.prototype, 'checked'],\n    [HTMLSelectElement.prototype, 'value'],\n    [HTMLTextAreaElement.prototype, 'value'],\n  ];\n  if (propertyDescriptor && propertyDescriptor.set) {\n    handlers.push(\n      ...hookProperties.map((p) =>\n        hookSetter<HTMLElement>(p[0], p[1], {\n          set() {\n            // mock to a normal event\n            eventHandler({ target: this } as Event);\n          },\n        }),\n      ),\n    );\n  }\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initStyleSheetObserver(cb: styleSheetRuleCallback): listenerHandler {\n  const insertRule = CSSStyleSheet.prototype.insertRule;\n  CSSStyleSheet.prototype.insertRule = function (rule: string, index?: number) {\n    const id = mirror.getId(this.ownerNode as INode);\n    if (id !== -1) {\n      cb({\n        id,\n        adds: [{ rule, index }],\n      });\n    }\n    return insertRule.apply(this, arguments);\n  };\n\n  const deleteRule = CSSStyleSheet.prototype.deleteRule;\n  CSSStyleSheet.prototype.deleteRule = function (index: number) {\n    const id = mirror.getId(this.ownerNode as INode);\n    if (id !== -1) {\n      cb({\n        id,\n        removes: [{ index }],\n      });\n    }\n    return deleteRule.apply(this, arguments);\n  };\n\n  return () => {\n    CSSStyleSheet.prototype.insertRule = insertRule;\n    CSSStyleSheet.prototype.deleteRule = deleteRule;\n  };\n}\n\nfunction initMediaInteractionObserver(\n  mediaInteractionCb: mediaInteractionCallback,\n  blockClass: blockClass,\n): listenerHandler {\n  const handler = (type: 'play' | 'pause') => (event: Event) => {\n    const { target } = event;\n    if (!target || isBlocked(target as Node, blockClass)) {\n      return;\n    }\n    mediaInteractionCb({\n      type: type === 'play' ? MediaInteractions.Play : MediaInteractions.Pause,\n      id: mirror.getId(target as INode),\n    });\n  };\n  const handlers = [on('play', handler('play')), on('pause', handler('pause'))];\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction mergeHooks(o: observerParam, hooks: hooksParam) {\n  const {\n    mutationCb,\n    mousemoveCb,\n    mouseInteractionCb,\n    scrollCb,\n    viewportResizeCb,\n    inputCb,\n    mediaInteractionCb,\n    styleSheetRuleCb,\n  } = o;\n  o.mutationCb = (...p: Arguments<mutationCallBack>) => {\n    if (hooks.mutation) {\n      hooks.mutation(...p);\n    }\n    mutationCb(...p);\n  };\n  o.mousemoveCb = (...p: Arguments<mousemoveCallBack>) => {\n    if (hooks.mousemove) {\n      hooks.mousemove(...p);\n    }\n    mousemoveCb(...p);\n  };\n  o.mouseInteractionCb = (...p: Arguments<mouseInteractionCallBack>) => {\n    if (hooks.mouseInteraction) {\n      hooks.mouseInteraction(...p);\n    }\n    mouseInteractionCb(...p);\n  };\n  o.scrollCb = (...p: Arguments<scrollCallback>) => {\n    if (hooks.scroll) {\n      hooks.scroll(...p);\n    }\n    scrollCb(...p);\n  };\n  o.viewportResizeCb = (...p: Arguments<viewportResizeCallback>) => {\n    if (hooks.viewportResize) {\n      hooks.viewportResize(...p);\n    }\n    viewportResizeCb(...p);\n  };\n  o.inputCb = (...p: Arguments<inputCallback>) => {\n    if (hooks.input) {\n      hooks.input(...p);\n    }\n    inputCb(...p);\n  };\n  o.mediaInteractionCb = (...p: Arguments<mediaInteractionCallback>) => {\n    if (hooks.mediaInteaction) {\n      hooks.mediaInteaction(...p);\n    }\n    mediaInteractionCb(...p);\n  };\n  o.styleSheetRuleCb = (...p: Arguments<styleSheetRuleCallback>) => {\n    if (hooks.styleSheetRule) {\n      hooks.styleSheetRule(...p);\n    }\n    styleSheetRuleCb(...p);\n  };\n}\n\nexport default function initObservers(\n  o: observerParam,\n  hooks: hooksParam = {},\n): listenerHandler {\n  mergeHooks(o, hooks);\n  const mutationObserver = initMutationObserver(\n    o.mutationCb,\n    o.blockClass,\n    o.inlineStylesheet,\n    o.maskAllInputs,\n  );\n  const mousemoveHandler = initMoveObserver(o.mousemoveCb, o.mousemoveWait);\n  const mouseInteractionHandler = initMouseInteractionObserver(\n    o.mouseInteractionCb,\n    o.blockClass,\n  );\n  const scrollHandler = initScrollObserver(o.scrollCb, o.blockClass);\n  const viewportResizeHandler = initViewportResizeObserver(o.viewportResizeCb);\n  const inputHandler = initInputObserver(\n    o.inputCb,\n    o.blockClass,\n    o.ignoreClass,\n    o.maskAllInputs,\n  );\n  const mediaInteractionHandler = initMediaInteractionObserver(\n    o.mediaInteractionCb,\n    o.blockClass,\n  );\n  const styleSheetObserver = initStyleSheetObserver(o.styleSheetRuleCb);\n\n  return () => {\n    mutationObserver.disconnect();\n    mousemoveHandler();\n    mouseInteractionHandler();\n    scrollHandler();\n    viewportResizeHandler();\n    inputHandler();\n    mediaInteractionHandler();\n    styleSheetObserver();\n  };\n}\n","import { snapshot } from 'rrweb-snapshot';\nimport initObservers from './observer';\nimport {\n  mirror,\n  on,\n  getWindowWidth,\n  getWindowHeight,\n  polyfill,\n} from '../utils';\nimport {\n  EventType,\n  event,\n  eventWithTime,\n  recordOptions,\n  IncrementalSource,\n  listenerHandler,\n} from '../types';\n\nfunction wrapEvent(e: event): eventWithTime {\n  return {\n    ...e,\n    timestamp: Date.now(),\n  };\n}\n\nlet wrappedEmit!: (e: eventWithTime, isCheckout?: boolean) => void;\n\nfunction record<T = eventWithTime>(\n  options: recordOptions<T> = {},\n): listenerHandler | undefined {\n  const {\n    emit,\n    checkoutEveryNms,\n    checkoutEveryNth,\n    blockClass = 'rr-block',\n    ignoreClass = 'rr-ignore',\n    inlineStylesheet = true,\n    maskAllInputs = false,\n    hooks,\n    mousemoveWait = 50,\n    packFn,\n  } = options;\n  // runtime checks for user options\n  if (!emit) {\n    throw new Error('emit function is required');\n  }\n\n  polyfill();\n\n  let lastFullSnapshotEvent: eventWithTime;\n  let incrementalSnapshotCount = 0;\n  wrappedEmit = (e: eventWithTime, isCheckout?: boolean) => {\n    emit(((packFn ? packFn(e) : e) as unknown) as T, isCheckout);\n    if (e.type === EventType.FullSnapshot) {\n      lastFullSnapshotEvent = e;\n      incrementalSnapshotCount = 0;\n    } else if (e.type === EventType.IncrementalSnapshot) {\n      incrementalSnapshotCount++;\n      const exceedCount =\n        checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\n      const exceedTime =\n        checkoutEveryNms &&\n        e.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\n      if (exceedCount || exceedTime) {\n        takeFullSnapshot(true);\n      }\n    }\n  };\n\n  function takeFullSnapshot(isCheckout = false) {\n    wrappedEmit(\n      wrapEvent({\n        type: EventType.Meta,\n        data: {\n          href: window.location.href,\n          width: getWindowWidth(),\n          height: getWindowHeight(),\n        },\n      }),\n      isCheckout,\n    );\n    const [node, idNodeMap] = snapshot(\n      document,\n      blockClass,\n      inlineStylesheet,\n      maskAllInputs,\n    );\n\n    if (!node) {\n      return console.warn('Failed to snapshot the document');\n    }\n\n    mirror.map = idNodeMap;\n    wrappedEmit(\n      wrapEvent({\n        type: EventType.FullSnapshot,\n        data: {\n          node,\n          initialOffset: {\n            left:\n              window.pageXOffset !== undefined\n                ? window.pageXOffset\n                : document?.documentElement.scrollLeft ||\n                  document?.body?.parentElement?.scrollLeft ||\n                  document?.body.scrollLeft ||\n                  0,\n            top:\n              window.pageYOffset !== undefined\n                ? window.pageYOffset\n                : document?.documentElement.scrollTop ||\n                  document?.body?.parentElement?.scrollTop ||\n                  document?.body.scrollTop ||\n                  0,\n          },\n        },\n      }),\n    );\n  }\n\n  try {\n    const handlers: listenerHandler[] = [];\n    handlers.push(\n      on('DOMContentLoaded', () => {\n        wrappedEmit(\n          wrapEvent({\n            type: EventType.DomContentLoaded,\n            data: {},\n          }),\n        );\n      }),\n    );\n    const init = () => {\n      takeFullSnapshot();\n\n      handlers.push(\n        initObservers(\n          {\n            mutationCb: (m) =>\n              wrappedEmit(\n                wrapEvent({\n                  type: EventType.IncrementalSnapshot,\n                  data: {\n                    source: IncrementalSource.Mutation,\n                    ...m,\n                  },\n                }),\n              ),\n            mousemoveCb: (positions, source) =>\n              wrappedEmit(\n                wrapEvent({\n                  type: EventType.IncrementalSnapshot,\n                  data: {\n                    source,\n                    positions,\n                  },\n                }),\n              ),\n            mouseInteractionCb: (d) =>\n              wrappedEmit(\n                wrapEvent({\n                  type: EventType.IncrementalSnapshot,\n                  data: {\n                    source: IncrementalSource.MouseInteraction,\n                    ...d,\n                  },\n                }),\n              ),\n            scrollCb: (p) =>\n              wrappedEmit(\n                wrapEvent({\n                  type: EventType.IncrementalSnapshot,\n                  data: {\n                    source: IncrementalSource.Scroll,\n                    ...p,\n                  },\n                }),\n              ),\n            viewportResizeCb: (d) =>\n              wrappedEmit(\n                wrapEvent({\n                  type: EventType.IncrementalSnapshot,\n                  data: {\n                    source: IncrementalSource.ViewportResize,\n                    ...d,\n                  },\n                }),\n              ),\n            inputCb: (v) =>\n              wrappedEmit(\n                wrapEvent({\n                  type: EventType.IncrementalSnapshot,\n                  data: {\n                    source: IncrementalSource.Input,\n                    ...v,\n                  },\n                }),\n              ),\n            mediaInteractionCb: (p) =>\n              wrappedEmit(\n                wrapEvent({\n                  type: EventType.IncrementalSnapshot,\n                  data: {\n                    source: IncrementalSource.MediaInteraction,\n                    ...p,\n                  },\n                }),\n              ),\n            styleSheetRuleCb: (r) =>\n              wrappedEmit(\n                wrapEvent({\n                  type: EventType.IncrementalSnapshot,\n                  data: {\n                    source: IncrementalSource.StyleSheetRule,\n                    ...r,\n                  },\n                }),\n              ),\n            blockClass,\n            ignoreClass,\n            maskAllInputs,\n            inlineStylesheet,\n            mousemoveWait,\n          },\n          hooks,\n        ),\n      );\n    };\n    if (\n      document.readyState === 'interactive' ||\n      document.readyState === 'complete'\n    ) {\n      init();\n    } else {\n      handlers.push(\n        on(\n          'load',\n          () => {\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.Load,\n                data: {},\n              }),\n            );\n            init();\n          },\n          window,\n        ),\n      );\n    }\n    return () => {\n      handlers.forEach((h) => h());\n    };\n  } catch (error) {\n    // TODO: handle internal error\n    console.warn(error);\n  }\n}\n\nrecord.addCustomEvent = <T>(tag: string, payload: T) => {\n  if (!wrappedEmit) {\n    throw new Error('please add custom event after start recording');\n  }\n  wrappedEmit(\n    wrapEvent({\n      type: EventType.Custom,\n      data: {\n        tag,\n        payload,\n      },\n    }),\n  );\n};\n\nexport default record;\n"],"names":["NodeType","__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","__values","o","m","Symbol","iterator","next","value","done","__read","r","e","ar","push","error","__spread","concat","_id","symbolAndNumberRegex","RegExp","getCssRulesString","rules","cssRules","Array","from","reduce","prev","cur","rule","isCSSImportRule","styleSheet","cssText","URL_IN_CSS_REF","RELATIVE_PATH","DATA_URI","absoluteToStylesheet","href","replace","origin","path1","path2","path3","url","filePath","test","indexOf","split","slice","join","stack","parts","pop","_i","parts_1","part","absoluteToDoc","doc","attributeValue","trim","a","createElement","transformAttribute","name","map","srcItem","urlAndSize","trimLeft","trimRight","getAbsoluteSrcsetString","location","serializeNode","blockClass","inlineStylesheet","maskAllInputs","nodeType","DOCUMENT_NODE","type","Document","childNodes","DOCUMENT_TYPE_NODE","DocumentType","publicId","systemId","ELEMENT_NODE","needBlock_1","classList","contains","forEach","className","tagName","processedTagName","toLowerCase","getValidTagName","attributes_1","_a","attributes","_b","stylesheet","styleSheets","find","rel","_cssText","sheet","innerText","textContent","repeat","checked","selectValue","parentElement","selected","rr_dataURL","toDataURL","rr_mediaState","paused","_c","getBoundingClientRect","width","height","rr_width","rr_height","Element","isSVG","el","SVGElement","undefined","needBlock","TEXT_NODE","parentTagName","parentNode","isStyle","Text","CDATA_SECTION_NODE","CDATA","COMMENT_NODE","Comment","serializeNodeWithId","skipChild","id","_serializedNode","console","warn","__sn","serializedNode","recordChild","serializedChildNode","on","fn","target","options","capture","passive","addEventListener","removeEventListener","EventType","IncrementalSource","MouseInteractions","MediaInteractions","ReplayerEvents","mirror","getId","getNode","removeNodeFromMap","child","has","throttle","func","wait","timeout","previous","arg","now","Date","leading","remaining","context","args","window","clearTimeout","trailing","setTimeout","getWindowHeight","innerHeight","document","documentElement","clientHeight","body","getWindowWidth","innerWidth","clientWidth","isBlocked","node","isTouchEvent","event","Boolean","changedTouches","moveKey","parentId","isINode","cb","Set","mutations","_this","processMutation","addQueue","pushAdd","nextId","nextSibling","adds","movedSet","_e","addedSet","isAncestorInSet","droppedSet","isParentRemoved","removes","add","every","shift","emit","oldValue","texts","getAttribute","attributeName","item","addedNodes","genAdds","removedNodes","nodeId","deepDelete","isAncestorRemoved","movedMap","targetId","delete","childN","payload","text","filter","attribute","emissionCallback","addsSet","some","set","initMouseInteractionObserver","handlers","keys","key","Number","isNaN","endsWith","eventKey","eventName","handler","clientX","clientY","x","y","getHandler","h","wrappedEmit","INPUT_TAGS","MASK_TYPES","lastInputValueMap","WeakMap","initInputObserver","ignoreClass","eventHandler","isChecked","hasTextInput","includes","cbWithDedup","querySelectorAll","v","lastInputValue","get","propertyDescriptor","getOwnPropertyDescriptor","HTMLInputElement","hookProperties","HTMLSelectElement","HTMLTextAreaElement","hookSetter","d","isRevoked","win","original","defineProperty","initObservers","hooks","mutationCb","mousemoveCb","mouseInteractionCb","scrollCb","viewportResizeCb","inputCb","mediaInteractionCb","styleSheetRuleCb","mutation","mousemove","mouseInteraction","scroll","viewportResize","input","mediaInteaction","styleSheetRule","mergeHooks","mutationBuffer","observer","mutationObserver","MutationBuffer","MutationObserver","processMutations","observe","attributeOldValue","characterData","characterDataOldValue","childList","subtree","mousemoveHandler","mousemoveWait","timeBaseline","positions","wrappedCb","isTouch","totalOffset","timeOffset","TouchMove","MouseMove","updatePosition","evt","initMoveObserver","mouseInteractionHandler","scrollHandler","scrollEl","scrollingElement","scrollLeft","scrollTop","initScrollObserver","viewportResizeHandler","initViewportResizeObserver","inputHandler","mediaInteractionHandler","Play","Pause","initMediaInteractionObserver","styleSheetObserver","insertRule","CSSStyleSheet","index","ownerNode","deleteRule","initStyleSheetObserver","disconnect","wrapEvent","timestamp","record","lastFullSnapshotEvent","checkoutEveryNms","checkoutEveryNth","_d","packFn","Error","NodeList","incrementalSnapshotCount","takeFullSnapshot","isCheckout","Meta","data","idNodeMap","snapshot","FullSnapshot","initialOffset","left","pageXOffset","top","pageYOffset","IncrementalSnapshot","exceedCount","exceedTime","handlers_1","DomContentLoaded","init_1","source","Mutation","MouseInteraction","Scroll","ViewportResize","Input","MediaInteraction","StyleSheetRule","readyState","Load","addCustomEvent","tag","Custom"],"mappings":"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"}